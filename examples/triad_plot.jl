#!/usr/bin/env julia
"""
triad_plot.jl

Visualization script for the triad calibration example. Consumes the
HDF5 output generated by `triad_compute.jl` and produces diagnostic
plots for scores, Jacobians, conjugate variables, responses, and
calibration convergence.

Run from the project root with:
    julia --project=examples examples/triad_plot.jl
"""

using Pkg
Pkg.activate(@__DIR__)

using GLMakie
using LinearAlgebra, Statistics, Printf
using HDF5

const DATA_FILE = joinpath(@__DIR__, "data", "triad_results.h5")
const FIG_DIR = joinpath(@__DIR__, "..", "figures")
mkpath(FIG_DIR)

"""
Color palette unified with reduced_1d_plot.jl
"""
const COL_ANALYTIC = :crimson      # Not currently present for triad but kept for consistency
const COL_GAUSS    = :black
const COL_NEURAL   = :steelblue
const COL_FD       = :darkorange

const METHOD_COLORS = Dict(
    :analytic    => COL_ANALYTIC,
    :gaussian    => COL_GAUSS,
    :neural      => COL_NEURAL,
    :finite_diff => COL_FD,
)

color_for(sym::Symbol) = get(METHOD_COLORS, sym, :gray40)

const PANEL_BG = RGBAf(1,1,1,1)
const FIG_BG   = RGBAf(1,1,1,1)

function publication_theme(; basefontsize=40, fontname="Helvetica", ticksize=30)
    Theme(
        fontsize = basefontsize,
        font = fontname,
        backgroundcolor = FIG_BG,
        Axis = (
            backgroundcolor = PANEL_BG,
            xlabelsize = basefontsize,
            ylabelsize = basefontsize,
            titlesize  = basefontsize+6,
            titlealign = :left,
            xgridvisible = false,
            ygridvisible = false,
            xticklabelsize = ticksize,
            yticklabelsize = ticksize,
            spinewidth = 1.1,
            topspinevisible = false,
            rightspinevisible = false,
            minorticksvisible = false,
        ),
        Legend = (
            framevisible = false,
            patchsize=(18,12),
            labelsize = basefontsize-6,
            titlegap = 6
        )
    )
end

"""
    save_pub(path, fig; px=2, tight=true)

Save figure at high resolution (pixel density multiplier px) and also export a PDF sibling.
Skips PDF if CairoMakie not loaded.
"""
function save_pub(path::AbstractString, fig; px::Real=2, tight::Bool=true)
    ext = splitext(path)[2]
    dir = dirname(path); mkpath(dir)
    save(path, fig; px_per_unit=px)
    if ext != ".pdf"
        if isdefined(Main, :CairoMakie)
            try
                pdfpath = joinpath(dir, splitext(basename(path))[1] * ".pdf")
                CairoMakie.save(pdfpath, fig)
            catch err
                @warn "PDF save failed; continuing with raster only" error=err
            end
        else
            @info "CairoMakie not loaded; skipping PDF export (PNG saved)."
        end
    end
end

"""
    panel_labels!(fig; style=:latin, offset=(10,-10), color=:black)

Annotate panels with (a), (b), ... in reading order.
"""
function panel_labels!(fig; style=:latin, offset=(10,-10), color=:black)
    axs = [ax for (_, ax) in contents(fig) if ax isa Axis]
    sort!(axs, by = x -> Tuple(parent_grid_position(x)))
    letters = style === :latin ? ["(a)","(b)","(c)","(d)","(e)","(f)","(g)","(h)","(i)","(j)"] : [string(i) for i in 1:length(axs)]
    for (k, ax) in enumerate(axs)
        k > length(letters) && break
        Label(fig, letters[k], tellwidth=false, tellheight=false,
              textcolor=color, fontsize=ax.titlesize,
              halign=:left, valign=:top,
              position = ax.scene.px_area[] .+ offset)
    end
end

function load_data(path::AbstractString)
    @assert isfile(path) "Data file not found: $(path). Run triad_compute.jl first."
    h5open(path, "r") do h
        meta = Dict(
            :θ_true => read(h, "meta/θ_true"),
            :θ_init => read(h, "meta/θ_init"),
            :Δt_eff => read(h, "meta/Δt_eff"),
            :Tmax => read(h, "meta/Tmax"),
            :obs_labels => read(h, "meta/obs_labels"),
            :pnames => read(h, "meta/pnames"),
            :state_labels => read(h, "meta/state_labels"),
            :methods => Symbol.(read(h, "meta/methods")),
            :calibration_methods => Symbol.(read(h, "meta/calibration_methods")),
            :x_norm => read(h, "slice/x_norm"),
            :x_phys => read(h, "slice/x_phys"),
            :x_axis => read(h, "slice/x_axis"),
        )
        data = Dict(
            :μ => read(h, "data/μ"),
            :Σ => read(h, "data/Σ"),
            :Xobs => read(h, "data/Xobs"),
            :A_target => read(h, "data/A_target"),
        )
        score = Dict{Symbol,Dict{Symbol,Array{Float64}}}()
        for name in keys(h["score"]) |> collect
            grp = h["score"][name]
            score[Symbol(name)] = Dict(:s => read(grp["s"]), :J => read(grp["J"]))
        end
        conjugate = Dict{Symbol,Array{Float64,2}}()
        for name in keys(h["conjugate"]) |> collect
            conjugate[Symbol(name)] = read(h, joinpath("conjugate", name))
        end
        responses = Dict{Symbol,Array{Float64,3}}()
        resp_grp = h["responses"]
        ts = read(resp_grp["ts"])
        for name in keys(resp_grp) |> collect
            name == "ts" && continue
            responses[Symbol(name)] = read(resp_grp[name]["C"])
        end
        jacobian = Dict{Symbol,Array{Float64,2}}()
        for name in keys(h["jacobian"]) |> collect
            jacobian[Symbol(name)] = read(h, joinpath("jacobian", name))
        end
        calibration = Dict{Symbol,Dict{Symbol,Array{Float64}}}()
        for name in keys(h["calibration"]) |> collect
            grp = h["calibration"][name]
            calibration[Symbol(name)] = Dict(
                :θ_iters => read(grp["θ_iters"]),
                :G_iters => read(grp["G_iters"]),
            )
        end
        return (meta = meta, data = data, score = score, conjugate = conjugate,
                responses = responses, jacobian = jacobian, calibration = calibration,
                ts = ts)
    end
end

data = load_data(DATA_FILE)
meta = data.meta
score = data.score
conjugate = data.conjugate
responses = data.responses
jacobian = data.jacobian
calibration = data.calibration
A_target = data.data[:A_target]
ts = data.ts
xs_phys = meta[:x_phys][1, :]

function fig_scores(meta, score)
    methods = sort(collect(keys(score)))
    isempty(methods) && return nothing
    state_labels = meta[:state_labels]
    fig = Figure(resolution = (760, 260 * length(state_labels) + 60))
    grid = fig[1, 1] = GridLayout(tellwidth=false, tellheight=false)
    line_objs = Makie.AbstractPlot[]; labels = String[]; legend_added = false
    for (i, label) in enumerate(state_labels)
        ax = Axis(grid[i, 1], xlabel = i == length(state_labels) ? "u₁ (slice)" : "",
                  ylabel = "s($(label))", title = "Score $(label)")
        for sym in methods
            plt = lines!(ax, xs_phys, score[sym][:s][i, :]; color = color_for(sym), linewidth = 5)
            if !legend_added
                push!(line_objs, plt); push!(labels, String(sym))
            end
        end
        legend_added = true
        tightlimits!(ax)
    end
    leg = Legend(fig, line_objs, labels; framevisible=false, orientation=:horizontal, tellwidth=false)
    leg.halign = :center
    fig[end+1, 1] = leg
    fig
end

function fig_jacobian(meta, score)
    methods = sort(collect(keys(score))); isempty(methods) && return nothing
    state_labels = meta[:state_labels]; L = length(xs_phys)
    fig = Figure(resolution = (760, 260 * length(state_labels) + 60))
    grid = fig[1, 1] = GridLayout(tellwidth=false, tellheight=false)
    line_objs = Makie.AbstractPlot[]; labels = String[]; legend_added = false
    for (i, label) in enumerate(state_labels)
        ax = Axis(grid[i, 1], xlabel = i == length(state_labels) ? "u₁ (slice)" : "",
                  ylabel = "∂s($(label))/∂x($(label))", title = "Jacobian $(label)")
        for sym in methods
            diag_vals = [score[sym][:J][i, i, k] for k in 1:L]
            plt = lines!(ax, xs_phys, diag_vals; color = color_for(sym), linewidth = 5)
            if !legend_added
                push!(line_objs, plt); push!(labels, String(sym))
            end
        end
        legend_added = true
    end
    leg = Legend(fig, line_objs, labels; framevisible=false, orientation=:horizontal, tellwidth=false)
    leg.halign = :center
    fig[end+1, 1] = leg
    fig
end

function fig_conjugate(meta, conjugate)
    methods = sort(collect(keys(conjugate))); isempty(methods) && return nothing
    pnames = meta[:pnames]
    fig = Figure(resolution = (360 * length(pnames), 360))
    grid = fig[1,1] = GridLayout(tellwidth=false)
    line_objs = Makie.AbstractPlot[]; labels = String[]; legend_added = false
    for (j, pname) in enumerate(pnames)
        ax = Axis(grid[1, j], xlabel="u₁ (slice)", ylabel = j==1 ? "B" : "", title = pname)
        for sym in methods
            plt = lines!(ax, xs_phys, conjugate[sym][j, :]; color=color_for(sym), linewidth=5)
            if !legend_added
                push!(line_objs, plt); push!(labels, String(sym))
            end
        end
        legend_added = true
    end
    leg = Legend(fig, line_objs, labels; framevisible=false, orientation=:horizontal, tellwidth=false)
    leg.halign=:center
    fig[end+1,1] = leg
    fig
end

function fig_responses(meta, responses, ts)
    methods = sort(collect(keys(responses)))
    (isempty(methods) || isempty(ts)) && return nothing
    obs_labels = meta[:obs_labels]; pnames = meta[:pnames]
    m = length(obs_labels); P = length(pnames)
    fig = Figure(resolution=(320*P, max(260*m, 260) + 60))
    grid = fig[1,1] = GridLayout(tellwidth=false, tellheight=false)
    line_objs = Makie.AbstractPlot[]; labels = String[]; legend_added = false
    for i in 1:m, j in 1:P
        ax = Axis(grid[i,j], xlabel = j==P ? "t" : "", ylabel = j==1 ? obs_labels[i] : "", title = pnames[j])
        for sym in methods
            plt = lines!(ax, ts, vec(@view responses[sym][i,j,:]); color=color_for(sym), linewidth=4.5)
            if !legend_added
                push!(line_objs, plt); push!(labels, String(sym))
            end
        end
        legend_added = true
    end
    leg = Legend(fig, line_objs, labels; framevisible=false, orientation=:horizontal, tellwidth=false)
    leg.halign=:center
    fig[end+1,1] = leg
    fig
end

function fig_calibration(meta, calibration, A_target)
    # Enforce explicit ordering for legend (Finite diff right after Analytic)
    available = Set(keys(calibration))
    preferred = [:analytic, :finite_diff, :gaussian, :neural]
    methods = [m for m in preferred if m in available]
    isempty(methods) && return nothing
    expected = Set(meta[:calibration_methods])
    missing = setdiff(expected, Set(methods))
    !isempty(missing) && @warn "Some calibration methods missing from file" missing
    obs_labels = meta[:obs_labels]; m = length(obs_labels)
    fig = Figure(resolution=(360*m, 360 + 60))
    grid = fig[1,1] = GridLayout(tellwidth=false)
    line_objs = Makie.AbstractPlot[]; labels = String[]; legend_added = false
    for j in 1:m
        ax = Axis(grid[1,j], xlabel="iteration", ylabel = j==1 ? obs_labels[j] : "", title = obs_labels[j])
        hlines!(ax, [A_target[j]]; color=:gray, linestyle=:dot, linewidth=2)
        for sym in methods
            G = calibration[sym][:G_iters]; its = 1:size(G,2)
            plt = lines!(ax, its, G[j,:]; color=color_for(sym), linewidth=5)
            if !legend_added
                push!(line_objs, plt); push!(labels, String(sym))
            end
        end
        legend_added = true
    end
    leg = Legend(fig, line_objs, labels; framevisible=false, orientation=:horizontal, tellwidth=false)
    leg.halign=:center
    fig[end+1,1] = leg
    fig
end

"""
Parameter trajectories over calibration iterations with horizontal true parameter lines.
"""
function fig_parameter_trajectories(meta, calibration)
    methods = sort(collect(keys(calibration))); isempty(methods) && return nothing
    θ_true = meta[:θ_true]; pnames = meta[:pnames]; P = length(pnames)
    fig = Figure(resolution=(340*P, 360 + 60))
    grid = fig[1,1] = GridLayout(tellwidth=false)
    line_objs = Makie.AbstractPlot[]; labels = String[]; legend_added = false
    for (j, pname) in enumerate(pnames)
        ax = Axis(grid[1,j], xlabel="iteration", ylabel = pname, title = pname)
        hlines!(ax, [θ_true[j]]; color=:gray, linestyle=:dot, linewidth=2)
        for sym in methods
            θ_iters = calibration[sym][:θ_iters]; its = 1:size(θ_iters, 2)
            plt = lines!(ax, its, θ_iters[j, :]; color=color_for(sym), linewidth=5)
            if !legend_added
                push!(line_objs, plt); push!(labels, String(sym))
            end
        end
        legend_added = true
    end
    leg = Legend(fig, line_objs, labels; framevisible=false, orientation=:horizontal, tellwidth=false)
    leg.halign=:center
    fig[end+1,1] = leg
    fig
end

"""
    fig_calibration_and_parameters(meta, calibration, A_target; basefontsize=30)

Clean combined figure with single legend (boxed), mapped labels (Neural->KGMM),
moderate fonts. Top row: observable convergence; bottom row: parameter trajectories.
"""
function fig_calibration_and_parameters(meta, calibration, A_target; basefontsize=26)
    methods = sort(collect(keys(calibration))); isempty(methods) && return nothing
    θ_true = meta[:θ_true]; pnames = meta[:pnames]; P = length(pnames)
    obs_labels = meta[:obs_labels]; m = length(obs_labels)
    label_map = Dict(
        "neural" => "KGMM",
        "gaussian" => "Gaussian",
        "finite_diff" => "Finite diff",
        "analytic" => "Analytic",
    )
    local_theme = publication_theme(basefontsize=basefontsize, ticksize=round(Int, 0.70*basefontsize))
    return with_theme(local_theme) do
    # Increased overall height slightly for better vertical spacing between rows
    # Previous height components: 2*250 + 100 = 600
    # New height: 2*280 + 110 = 670 (~11% increase)
    fig = Figure(resolution=(max(260*P, 260*m), 2*280 + 110))
        grid_top = fig[1,1] = GridLayout(tellwidth=false)
        grid_bot = fig[2,1] = GridLayout(tellwidth=false)
        line_objs = Makie.AbstractPlot[]; labels = String[]; seen = Set{Symbol}()
        # Top row (observables)
        for j in 1:m
            ax = Axis(grid_top[1,j], xlabel = "", ylabel = j==1 ? "Aᵢ" : "", title = obs_labels[j])
            hlines!(ax, [A_target[j]]; color=:gray55, linestyle=:dot, linewidth=1.6)
            for sym in methods
                G = calibration[sym][:G_iters]; its = 1:size(G,2)
                plt = lines!(ax, its, G[j,:]; color=color_for(sym), linewidth=3.5)
                if !(sym in seen)
                    push!(line_objs, plt)
                    push!(labels, get(label_map, String(sym), String(sym)))
                    push!(seen, sym)
                end
            end
            tightlimits!(ax)
        end
        # Bottom row (parameters)
        for (j, pname) in enumerate(pnames)
            ax = Axis(grid_bot[1,j], xlabel = "iteration", ylabel = j==1 ? "θᵢ" : "", title = pname)
            hlines!(ax, [θ_true[j]]; color=:gray55, linestyle=:dot, linewidth=1.6)
            for sym in methods
                θ_iters = calibration[sym][:θ_iters]; its = 1:size(θ_iters, 2)
                lines!(ax, its, θ_iters[j, :]; color=color_for(sym), linewidth=3.5)
            end
            tightlimits!(ax)
        end
        leg = Legend(fig, line_objs, labels; orientation=:horizontal, framevisible=true, tellwidth=false)
        leg.halign = :center
        fig[end+1,1] = leg
        # Simple sanity check (unique labels)
        if length(labels) != length(unique(labels))
            @warn "Duplicate legend labels detected" labels
        end
        fig
    end
end

# --- PNG dimension check utilities ---
"""
    png_dims(path) -> (width, height)

Read the IHDR chunk of a PNG to get its pixel dimensions without extra dependencies.
Returns (nothing, nothing) if the file is not a PNG or an error occurs.
"""
function png_dims(path::AbstractString)
    try
        open(path, "r") do io
            sig = read(io, UInt8, 8)
            pngsig = UInt8[0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A]
            sig == pngsig || return (nothing, nothing)
            # Read length (4), type (4), IHDR data (13), CRC (4) = 25 more bytes
            chunk = read(io, UInt8, 25)
            length(chunk) == 25 || return (nothing, nothing)
            # Ensure it's IHDR
            chunk[5:8] == UInt8[0x49,0x48,0x44,0x52] || return (nothing, nothing)
            # IHDR data starts at byte 9 within chunk (after length+type)
            w = reinterpret(UInt32, chunk[9:12])[1] |> ntoh
            h = reinterpret(UInt32, chunk[13:16])[1] |> ntoh
            return (Int(w), Int(h))
        end
    catch
        return (nothing, nothing)
    end
end

"""
    verify_png(path; warn_if_large=true, max_width=6000)

Print a short report (dimensions, file size KB) after saving a PNG.
Warns if width exceeds `max_width` when `warn_if_large` is true.
"""
function verify_png(path; warn_if_large=true, max_width=6000, retries=5)
    for attempt in 1:retries
        (w,h) = png_dims(path)
        if w !== nothing
            size_bytes = isfile(path) ? filesize(path) : missing
            kb = size_bytes === missing ? missing : round(Int, size_bytes/1024)
            println("[PNG CHECK] $(basename(path)): $(w)x$(h) px, $(kb) KB (attempt $(attempt))")
            if warn_if_large && w > max_width
                println("[PNG CHECK] WARNING: width $(w) exceeds $(max_width) px. Consider reducing size.")
            end
            return
        end
        sleep(0.1)
    end
    println("[PNG CHECK] Could not read PNG header for $(path) after $(retries) attempts")
end

function save_maybe(fig, name::AbstractString)
    fig === nothing && return
    path = joinpath(FIG_DIR, name)
    save_pub(path, fig; px=3)
    println("Saved $(name) and PDF sibling to figures/")
end

save_maybe(fig_scores(meta, score), "triad_scores.png")
save_maybe(fig_jacobian(meta, score), "triad_jacobian_diag.png")
save_maybe(fig_conjugate(meta, conjugate), "triad_conjugate.png")
save_maybe(fig_responses(meta, responses, ts), "triad_responses.png")
save_maybe(fig_calibration(meta, calibration, A_target), "triad_calibration.png")
save_maybe(fig_parameter_trajectories(meta, calibration), "triad_parameter_trajectories.png")
begin
    fig_combined = fig_calibration_and_parameters(meta, calibration, A_target)
    save_maybe(fig_combined, "triad_calibration_parameters.png")
    verify_png(joinpath(FIG_DIR, "triad_calibration_parameters.png"))
end

println("Completed triad plotting.")
